/** 
 * @file crfCommon.c 
 * @version 1.0
 * @since 2013-05-11
 * @author Jimmy Lin (u5223173) - u5223173@uds.anu.edu.au
 *
 * Edited by MacVim
 * Info auto-generated by Snippet 
 * */
int learnLambda(cv::Mat img) {
    const int nNumPixels = cv::norm(seg, cv::NORM_INF) + 1;
    const int nLabels = 2; // salient or not salient

    // get feature maps for currently processed image
    cv::Mat msc = getMultiScaleContrast(img);
    cv::Mat csh = getCentreSurroundHistogram(img);
    cv::Mat cdi = getSpatialDistribution(img); 

    // Build conditional Markov random field.
    drwnVarUniversePtr universe(new drwnVarUniverse(nNumPixels, nLabels));
    drwnTableFactorStorage storage; // allocate storage before graph
    drwnFactorGraph graph(universe);

    // Add multi-scale contrast potentials for each pixel.
    vector<double> unary;
    for (int n = 0; n < nNumPixels; n++) {
        // this unary potential is for multi-scale contrast
        const vector<double> features = getSuperpixelFeatures(img, seg, n);
        classifier.getClassScores(features, unary);

        drwnTableFactor *psi = new drwnTableFactor(universe);
        psi->addVariable(n);
        psi->copy(&unary[0]);
        psi->scale(-1.0);

        graph.addFactor(psi);
    }

    // Add unary potentials for each pixel.
    vector<double> unary;
    for (int n = 0; n < nNumPixels; n++) {
        // this unary potential is for center-surround histogram
        const vector<double> features = getSuperpixelFeatures(img, seg, n);
        classifier.getClassScores(features, unary);

        drwnTableFactor *psi = new drwnTableFactor(universe);
        psi->addVariable(n);
        psi->copy(&unary[0]);
        psi->scale(-1.0);

        graph.addFactor(psi);
    }

    // Add unary potentials for each pixel.
    vector<double> unary;
    for (int n = 0; n < nNumPixels; n++) {
        // this unary potential is for spatial color distribution
        const vector<double> features = getSuperpixelFeatures(img, seg, n);
        classifier.getClassScores(features, unary);

        drwnTableFactor *psi = new drwnTableFactor(universe);
        psi->addVariable(n);
        psi->copy(&unary[0]);
        psi->scale(-1.0);

        graph.addFactor(psi);
    }

    // Find superpixel neighbours.
    set<pair<int, int> > neighbours;
    for (int y = 0; y < img.rows; y++) {            
        const int *p = seg.ptr<const int>(y, 0);
        const int *q = (y > 0) ? seg.ptr<const int>(y - 1, 0) : NULL;
        for (int x = 0; x < img.cols; x++) {
            if ((x > 0) && (p[x - 1] != p[x])) {
                neighbours.insert(make_pair(std::min(p[x - 1], p[x]), std::max(p[x - 1], p[x])));
            }

            if ((y > 0) && (q[x] != p[x])) {
                neighbours.insert(make_pair(std::min(q[x], p[x]), std::max(q[x], p[x])));
            }
        }
    }

    // Add pairwise potentials (using shared factor storage).
    for (set<pair<int, int> >::const_iterator it = neighbours.begin();
            it != neighbours.end(); ++it) {

        drwnTableFactor *psi = new drwnTableFactor(universe, &storage);
        psi->addVariable(it->first);
        psi->addVariable(it->second);

        graph.addFactor(psi);
    }

    // Populate pairwise term as a Potts model.
    for (int lblA = 0; lblA < nLabels; lblA++) {
        for (int lblB = 0; lblB < nLabels; lblB++) {
            storage[lblA * nLabels + lblB] = (lblA == lblB) ? 0.0 : lambda;
        }
    }

    // Run inference in the CRF.
    graph.connectGraph();
    drwnAsyncMaxProdInference inf(graph);
    drwnFullAssignment assignment;
    drwnMessagePassingMAPInference::MAX_ITERATIONS = 100;
    inf.inference(assignment);

    // Convert superpixel labels to pixel colours.
    cv::Mat lbls(img.rows, img.cols, CV_8UC3);
    for (int y = 0; y < img.rows; y++) {
        for (int x = 0; x < img.cols; x++) {
            const int id = seg.at<int>(y, x);
            const unsigned int colour = gMultiSegRegionDefs.color(assignment[id]);
            lbls.at<cv::Vec3b>(y, x) = cv::Vec3b(gMultiSegRegionDefs.blue(colour),
                    gMultiSegRegionDefs.green(colour), gMultiSegRegionDefs.red(colour));
        }
    }
}
