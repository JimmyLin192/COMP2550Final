/** 
 * @file crfCommon.c 
 * @version 1.0
 * @since 2013-05-11
 * @author Jimmy Lin (u5223173) - u5223173@uds.anu.edu.au
 *
 * Edited by MacVim
 * Info auto-generated by Snippet 
 * */
#define index(x,y) y*imgWidth+x

int inference (cv::Mat img, vector<double> lambda) {
    const int nNumPixels = img.rows * img.cols;
    const int nLabels = 2; // salient or not salient
    const int imgWidth = img.cols;
    const int imgHeight = img.rows;

    // get feature maps for currently processed image
    cv::Mat msc = getMultiScaleContrast(img);
    cv::Mat csh = getCentreSurroundHistogram(img);
    cv::Mat cdi = getSpatialDistribution(img); 

    // Build conditional Markov random field.
    drwnVarUniversePtr universe(new drwnVarUniverse(nNumPixels, nLabels));
    drwnTableFactorStorage storage; // allocate storage before graph
    drwnFactorGraph graph(universe);

    // TODO the following construction need to be dicussed.
    vector<double> unary;
    for (int i = 0 ; i < imgHeight; i ++) {
        for (int j = 0 ; j < imgWidth; j ++ ) {
            // this unary potential is for multi-scale contrast
            int n = i * imgHeight + j;
            double tempMSC = msc.at<double>(i, j);
            double tempCSH = csh.at<double>(i, j);
            double tempCDI = cdi.at<double>(i, j);
            
            drwnTableFactor *psi = new drwnTableFactor(universe);
            psi->addVariable(n);
            psi->copy(&unary[0]);
            psi->scale(-1.0);

            graph.addFactor(psi);
        }
    }

    // Add unary potentials for each pixel.
    vector<double> unary;
    for (int n = 0; n < nNumPixels; n++) {
        // this unary potential is for center-surround histogram
        const vector<double> features = getSuperpixelFeatures(img, seg, n);
        classifier.getClassScores(features, unary);

        drwnTableFactor *psi = new drwnTableFactor(universe);
        psi->addVariable(n);
        psi->copy(&unary[0]);
        psi->scale(-1.0);

        graph.addFactor(psi);
    }

    // Add unary potentials for each pixel.
    vector<double> unary;
    for (int n = 0; n < nNumPixels; n++) {
        // this unary potential is for spatial color distribution
        const vector<double> features = getSuperpixelFeatures(img, seg, n);
        classifier.getClassScores(features, unary);

        drwnTableFactor *psi = new drwnTableFactor(universe);
        psi->addVariable(n);
        psi->copy(&unary[0]);
        psi->scale(-1.0);

        graph.addFactor(psi);
    }

    // Find pixel neighbours.
    set<pair<int, int> > neighbours;
    for (int y = 0; y < img.rows; y++) {            
        for (int x = 0; x < img.cols; x++) {
            if (x > 0) {
                neighbours.insert(make_pair(index(x-1, y), index(x,y)));
            }

            if (y > 0) {
                neighbours.insert(make_pair(index(x,y-1), index(x,y)));
            }
        }
    }

    // Add pairwise potentials (using shared factor storage).
    for (set<pair<int, int> >::const_iterator it = neighbours.begin();
            it != neighbours.end(); ++it) {

        drwnTableFactor *psi = new drwnTableFactor(universe, &storage);
        psi->addVariable(it->first);
        psi->addVariable(it->second);

        graph.addFactor(psi);
    }

    // Populate pairwise term as a Potts model.
    for (int lblA = 0; lblA < nLabels; lblA++) {
        for (int lblB = 0; lblB < nLabels; lblB++) {
            storage[lblA * nLabels + lblB] = (lblA == lblB) ? 0.0 : lambda;
        }
    }

    // Run inference in the CRF.
    graph.connectGraph();
    drwnAsyncMaxProdInference inf(graph);
    drwnFullAssignment assignment;
    drwnMessagePassingMAPInference::MAX_ITERATIONS = 100;
    inf.inference(assignment);

    // Convert superpixel labels to pixel colours.
    cv::Mat lbls(img.rows, img.cols, CV_8UC3);
    for (int y = 0; y < img.rows; y++) {
        for (int x = 0; x < img.cols; x++) {
            const int id = seg.at<int>(y, x);
            const unsigned int colour = gMultiSegRegionDefs.color(assignment[id]);
            lbls.at<cv::Vec3b>(y, x) = cv::Vec3b(gMultiSegRegionDefs.blue(colour),
                    gMultiSegRegionDefs.green(colour), gMultiSegRegionDefs.red(colour));
        }
    }
}
